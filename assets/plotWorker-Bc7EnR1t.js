(function(){"use strict";function g(s){const a={};for(let n=0;n<s.length;n++){const e=s[n].trim();if(e.startsWith("========== ")&&e.endsWith(" ==========")){e.replace(/========== | ==========/g,"");continue}if(!(!e||e.includes("=========="))&&e.includes(",")){const c=e.split(",");if(c.length>=2){const i=c[0].trim(),t=c.slice(1).join(",").trim().replace(/"/g,"");a[i]=t}}}return a}function d(s,a){const n={name:a,data:[],xLabels:[],yLabels:[]};let e=!1,c=!1,i=!1;for(let t=0;t<s.length;t++){const r=s[t].trim();if(r){if(r.includes(a)){e=!0;continue}if(e){if(r.startsWith("==========")||r==="------------------- END -------------------"||r.endsWith("Histogram")&&!r.includes(a))break;const o=r.split(",").map(l=>l.trim());if(!c&&o[0]===""&&o[1]===""){const l=o.slice(2).filter(u=>u!==""&&!isNaN(parseFloat(u)));if(l.length>0){n.xLabels=l.map(u=>parseFloat(u)),c=!0;continue}}if(c&&((r.startsWith("Engine Speed,")||o[0]===""&&o.length>2)&&(i=!0),i)){const l=parseFloat(o[1]);if(!isNaN(l)){n.yLabels.push(l);const u=o.slice(2).map(m=>{const f=parseFloat(m);return isNaN(f)?0:f});n.data.push(u)}}}}}return n}function k(s){s.split(`
`);const a={},n=s.match(/Speed\/Load Histogram[\s\S]*?(?=Knock Histogram|ECT Histogram|Intake Backfire|==========|$)/);n&&(a.speedLoad=d(n[0].split(`
`),"Speed/Load Histogram"));const e=s.match(/Knock Histogram[\s\S]*?(?=ECT Histogram|Intake Backfire|==========|$)/);e&&(a.knock=d(e[0].split(`
`),"Knock Histogram"));const c=s.match(/ECT Histogram[\s\S]*?(?=Intake Backfire|==========|$)/);if(c){const r={name:"ECT Histogram",data:[],xLabels:[],yLabels:[0]},o=[],l=c[0].split(`
`);for(const u of l){const m=u.trim();if(!m||m.includes("ECT Histogram")||m.includes("ECT (deg F)"))continue;const f=u.split(",").map(p=>p.trim());if(f.length>=3){const p=parseFloat(f[1]),h=parseFloat(f[2]);!isNaN(p)&&!isNaN(h)&&(r.xLabels.push(p),o.push(h))}}r.data=[o],a.ect=r}const i=s.match(/Intake Backfire Histogram \(Lifetime\)[\s\S]*?(?=Intake Backfire Histogram \(Recent\)|Intake Backfire Events|==========|$)/);i&&(a.backfireLifetime=d(i[0].split(`
`),"Intake Backfire Histogram (Lifetime)"));const t=s.match(/Intake Backfire Histogram \(Recent\)[\s\S]*?(?=Intake Backfire Events|==========|$)/);return t&&(a.backfireRecent=d(t[0].split(`
`),"Intake Backfire Histogram (Recent)")),a}function S(s){const a=[],n=s.split(`
`);let e=null,c=!1;for(let i=0;i<n.length;i++){const t=n[i].trim();if(t.includes("========== Fault Snap Shot Data ==========")){c=!0;continue}if(c){if(t.startsWith("DTC ")){e&&a.push(e);const r=t.match(/DTC (\d+): (.+)/);r&&(e={code:r[1],description:r[2],details:[],snapshot:{},occurredThisCycle:!1,causedShutdown:!1,startsSinceActive:0,occurrenceCount:0,initialOccurrence:0,lastOccurrence:0})}else if(e){if(t.includes("Fault")&&t.includes("occur")&&t.includes("key cycle"))e.occurredThisCycle=!t.includes("did not"),e.details.push(t);else if(t.includes("Fault caused")&&t.includes("shutdown"))e.causedShutdown=!0,e.details.push(t);else if(t.includes("Starts since fault was active")){const r=t.match(/Starts since fault was active:\s*(\d+)/);r&&(e.startsSinceActive=parseInt(r[1],10)),e.details.push(t)}else if(t.includes("Occurrence count:")){const r=t.match(/Occurrence count:\s*(\d+)/);r&&(e.occurrenceCount=parseInt(r[1],10)),e.details.push(t)}else if(t.includes("Initial occurrence:")){const r=t.match(/Initial occurrence:\s*([\d.]+)\s*eng hours/);r&&(e.initialOccurrence=parseFloat(r[1])),e.details.push(t)}else if(t.includes("Last occurrence:")){const r=t.match(/Last occurrence:\s*([\d.]+)\s*eng hours/);r&&(e.lastOccurrence=parseFloat(r[1])),e.details.push(t)}else if(t.includes("Fault")||t.includes("MIL countdown")||t.includes("Went previously active"))e.details.push(t);else if(t.includes(",")&&!t.startsWith("=")){const r=t.split(",").map(o=>o.trim());if(r.length>=2&&r[0]!==""){const o=r[0],l=parseFloat(r[1]);e.snapshot[o]=isNaN(l)?r[1]:l}}else if(t.startsWith("======")&&!t.includes("Fault Snap Shot Data"))break}}}return e&&a.push(e),a}function I(s){try{const a=s.split(`
`),n=g(a),e=k(s),c=S(s);return{ecmInfo:n,histograms:e,faults:c,parsed:!0,error:null}}catch(a){return console.error("Error parsing ECM data:",a),{ecmInfo:{},histograms:{},faults:[],parsed:!1,error:a.message}}}function H(s){if(!s||!s.data.length)return[];const a=[];for(let n=0;n<s.yLabels.length;n++)for(let e=0;e<s.xLabels.length;e++){const c=s.data[n]?.[e]||0;c>0&&a.push({x:s.xLabels[e],y:s.yLabels[n],value:c,histogram:s.name})}return a}function L(s){const a={totalFaults:s.faults.length,histogramCount:Object.keys(s.histograms).length,engineHours:parseFloat(s.ecmInfo["Hour meter"])||0,engineStarts:parseInt(s.ecmInfo["Cumulative Starts"])||0,softwareVersion:s.ecmInfo["ECI Mot XLS Rev"]||"Unknown",hardwarePN:s.ecmInfo["ECI H/W P/N"]||"Unknown",serialNumber:s.ecmInfo["ECI H/W S/N"]||"Unknown"};return a.histogramStats={},Object.entries(s.histograms).forEach(([n,e])=>{const c=e.data.flat().reduce((i,t)=>i+(t||0),0);a.histogramStats[n]={totalHours:c,dataPoints:e.data.length*(e.xLabels.length||0)}}),a}function b(s){try{const a=new TextDecoder("utf-8").decode(s),n=I(a);if(!n.parsed)throw new Error(n.error||"Failed to parse ECM data");const e=L(n),c={};return Object.entries(n.histograms).forEach(([i,t])=>{c[i]=H(t)}),{ecmInfo:n.ecmInfo,histograms:n.histograms,faults:n.faults,stats:e,chartData:c,processed:!0,error:null}}catch(a){return console.error("Worker processing error:",a),{ecmInfo:{},histograms:{},faults:[],stats:{},chartData:{},processed:!1,error:a.message}}}function y(s,a){try{const e=new TextDecoder("utf-8").decode(s).split(`
`),c={};let i="General";c[i]=[];for(const r of e){const o=r.trim();o.startsWith("========== ")&&o.endsWith(" ==========")?(i=o.replace(/========== | ==========/g,""),c[i]=[]):c[i].push(r)}const t=c[a]||c.General||[];return{name:a,rows:t.map((r,o)=>({id:o+1,content:r})),parsed:!0}}catch(n){return{name:a,rows:[],error:n.message,parsed:!1}}}self.onmessage=function(s){const{type:a,buffer:n,name:e}=s.data;try{if(a==="load"){const c=b(n);self.postMessage({type:"loaded",...c})}else if(a==="rawSheet"){const c=y(n,e);self.postMessage({type:"rawSheet",name:e,rows:c.rows,parsed:c.parsed,error:c.error})}else self.postMessage({type:"error",message:`Unknown message type: ${a}`})}catch(c){self.postMessage({type:"error",message:`Worker error: ${c.message}`})}},self.onerror=function(s){self.postMessage({type:"error",message:`Worker error: ${s.message}`})}})();
